library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std_unsigned.all;

-- AXI Peripheral Module
--
-- This is a file generated by Vivado using the "Create & Package IP" flow.
-- It provides an AXI Lite port for configuriation of the underlying component,
-- two AXI Stream ports for receiving and transmitting data, and all the metadata
-- required for use in a Vivado Block Degigns.
--
-- The entity defined in this file is an encapsulation of the `core_logic` component,
-- where all of the funcionality of the project resides. In this file, the formal AXI Stream Ports
-- are simply connected to the `core_logic` component with some signals being unused.
--
-- Behind the AXI Lite port there is some logic, namely three buffers, that ensure `core_logic`
-- will receive a write address simultaneously with the payload, something that should not be assumed
-- according to the AXI4 standard. Additionally, this logic receives `core_logic`'s response and will handle
-- passing it to the command issuer.

entity mat_mult_accelerator is
	generic (
		-- User parameters ---------------------
		G_INPUT_ELEM_WIDTH	: integer := 8;
		G_OUTPUT_ELEM_WIDTH	: integer := 16;
		----------------------------------------

		-- Parameters of Axi Slave Bus Interface S_AXI_Settings
		G_S_AXI_Settings_DATA_WIDTH	: integer	:= 32;
		G_S_AXI_Settings_ADDR_WIDTH	: integer	:= 4;

		-- Parameter of AXI Stream buses width
		G_AXI_STREAM_TDATA_WIDTH	: integer	:= 32
	);
	port (
		-- The High Frequency clock driving `core_logic` and stream data
		DATA_CLK, DATA_RST		: in std_logic;

		-- Ports of Axi Slave Bus Interface S_AXI_Settings
		S_AXI_SETTINGS_AWADDR	: in std_logic_vector(G_S_AXI_Settings_ADDR_WIDTH-1 downto 0);
		S_AXI_SETTINGS_AWPROT	: in std_logic_vector(2 downto 0);
		S_AXI_SETTINGS_AWVALID	: in std_logic;
		S_AXI_SETTINGS_AWREADY	: out std_logic;
		S_AXI_SETTINGS_WDATA	: in std_logic_vector(G_S_AXI_Settings_DATA_WIDTH-1 downto 0);
		S_AXI_SETTINGS_WSTRB	: in std_logic_vector((G_S_AXI_Settings_DATA_WIDTH/8)-1 downto 0);
		S_AXI_SETTINGS_WVALID	: in std_logic;
		S_AXI_SETTINGS_WREADY	: out std_logic;
		S_AXI_SETTINGS_BRESP	: out std_logic_vector(1 downto 0);
		S_AXI_SETTINGS_BVALID	: out std_logic;
		S_AXI_SETTINGS_BREADY	: in std_logic;
		S_AXI_SETTINGS_ARADDR	: in std_logic_vector(G_S_AXI_Settings_ADDR_WIDTH-1 downto 0);
		S_AXI_SETTINGS_ARPROT	: in std_logic_vector(2 downto 0);
		S_AXI_SETTINGS_ARVALID	: in std_logic;
		S_AXI_SETTINGS_ARREADY	: out std_logic;
		S_AXI_SETTINGS_RDATA	: out std_logic_vector(G_S_AXI_Settings_DATA_WIDTH-1 downto 0);
		S_AXI_SETTINGS_RRESP	: out std_logic_vector(1 downto 0);
		S_AXI_SETTINGS_RVALID	: out std_logic;
		S_AXI_SETTINGS_RREADY	: in std_logic;

		-- Ports of Axi Slave Bus Interface S_AXI_STREAM
		S_AXI_STREAM_TREADY		: out std_logic;
		S_AXI_STREAM_TDATA		: in std_logic_vector(G_AXI_STREAM_TDATA_WIDTH-1 downto 0);
		S_AXI_STREAM_TSTRB		: in std_logic_vector((G_AXI_STREAM_TDATA_WIDTH/8)-1 downto 0);
		S_AXI_STREAM_TLAST		: in std_logic;
		S_AXI_STREAM_TVALID		: in std_logic;

		-- Ports of Axi Master Bus Interface M_AXI_STREAM
		M_AXI_STREAM_TVALID		: out std_logic;
		M_AXI_STREAM_TDATA		: out std_logic_vector(G_AXI_STREAM_TDATA_WIDTH-1 downto 0);
		M_AXI_STREAM_TSTRB		: out std_logic_vector((G_AXI_STREAM_TDATA_WIDTH/8)-1 downto 0);
		M_AXI_STREAM_TLAST		: out std_logic;
		M_AXI_STREAM_TREADY		: in std_logic
	);
end mat_mult_accelerator;

architecture arch_imp of mat_mult_accelerator is
-- Core Logic
	component core_logic is
		generic (
			g_axi_port_width	: positive;
			g_input_elem_width	: positive;
			g_output_elem_width	: positive;

			g_ctrl_address_width: positive;
			g_ctrl_data_width	: positive
		);
		port (
			DATA_CLK		: IN  std_logic;
			RST				: IN  std_logic;
			DATAIN_VALID	: IN  std_logic;
			DATAIN_READY	: OUT std_logic;
			DATAIN_LAST		: IN  std_logic;
			DATAIN			: IN  std_logic_vector(g_axi_port_width-1 downto 0);
			DATAOUT_VALID	: OUT std_logic;
			DATAOUT_READY	: IN  std_logic;
			DATAOUT_LAST	: OUT std_logic;
			DATAOUT			: OUT std_logic_vector(g_axi_port_width-1 downto 0);
			CONTROL_START	: IN  std_logic;
			CONTROL_READY	: OUT std_logic;
			CONTROL_ADDR	: IN  std_logic_vector(g_ctrl_address_width-1 downto 0);
			CONTROL_DATA	: IN  std_logic_vector(g_ctrl_data_width-1 downto 0);
			CONTROL_RESP	: OUT std_logic_vector(1 downto 0) := (others=>'0')
		);
	end component;

-- Constants/Types
	constant c_high	: std_logic := '1';
	constant c_low	: std_logic := '0';
	type axilite_state_t is (st_reset, st_idle, st_transmit, st_wait, st_waitfor_bready, st_transmit_resp);

-- Registers
	-- AXI Lite Port Side Communication state (slow clock)
	signal axilite_state	: axilite_state_t := st_reset;

	-- Registers for AXI Lite data passing
	signal reg_addr		: std_logic_vector(G_S_AXI_Settings_ADDR_WIDTH-1 downto 0) := (others=>'0');
	signal reg_data		: std_logic_vector(G_S_AXI_Settings_DATA_WIDTH-1 downto 0) := (others=>'0');
	signal reg_resp		: std_logic_vector(1 downto 0) := "00";

	signal axilite_got_addr : std_logic := '0';
	signal axilite_got_data : std_logic := '0';
	signal axilite_got_resp	: std_logic := '0';

-- Signals
	signal corlog_ctrl_ready: std_logic := '0';
	signal corlog_ctrl_start: std_logic := '0';
	signal corlog_resp_out	: std_logic_vector(1 downto 0) := "00";

-- I/O Signals
	signal axilite_awready	: std_logic := '0';
	signal axilite_wready	: std_logic := '0';
	signal axilite_bready	: std_logic := '0';

	signal axilite_awvalid	: std_logic := '0';
	signal axilite_wvalid	: std_logic := '0';
	signal axilite_bvalid	: std_logic := '0';

	signal axilite_awaddr	: std_logic_vector(G_S_AXI_Settings_ADDR_WIDTH-1 downto 0) := (others=>'0');
	signal axilite_wdata	: std_logic_vector(G_S_AXI_Settings_DATA_WIDTH-1 downto 0) := (others=>'0');

begin
	-- Wire Address ports with signals
	S_AXI_SETTINGS_AWREADY <= axilite_awready;
	axilite_awvalid <= S_AXI_SETTINGS_AWVALID;
	axilite_awaddr <= S_AXI_SETTINGS_AWADDR;

	-- Wire Data ports with signals
	S_AXI_SETTINGS_WREADY <= axilite_wready;
	axilite_wvalid <= S_AXI_SETTINGS_WVALID;
	axilite_wdata <= S_AXI_SETTINGS_WDATA;

	-- Wire Response ports with signals
	axilite_bready <= S_AXI_SETTINGS_BREADY;
	S_AXI_SETTINGS_BVALID <= axilite_bvalid;
	S_AXI_SETTINGS_BRESP <= reg_resp;

	-- As long as we haven't received any arguments we are ready to receive them
	process(data_clk)
	begin
		if rising_edge(data_clk) then
			if data_rst = '1' then
				axilite_awready <= '0';
			else
				axilite_awready <= not axilite_got_addr;
			end if;
		end if;
	end process;

	process(data_clk)
	begin
		if rising_edge(data_clk) then
			if data_rst = '1' then
				axilite_wready <= '0';
			else
				axilite_wready <= not axilite_got_data;
			end if;
		end if;
	end process;

	-- Set `ctrl_start` for one fast cycle during the appropriate state;
	-- If `core_logic` isn't ready to receive a command we might stay longer
	-- than one cycle in this state
	corlog_ctrl_start <= '1' when axilite_state = st_transmit else '0';

	-- AXI Port Communication State Machine
	process(data_clk)
	begin
		if rising_edge(data_clk) then
			if data_rst = '1' then
				axilite_state <= st_reset;
			else
				case axilite_state is
					when st_reset =>
						axilite_state <= st_idle;

					-- Wait for address and data arguments
					when st_idle =>
						axilite_state <= st_transmit when (axilite_got_addr = '1' and axilite_got_data = '1') else st_idle;

					-- Forward arguments to `core_logic` and raise `corlog_start`
					when st_transmit =>
						axilite_state <= axilite_state when corlog_ctrl_ready = '0' else st_wait;

					-- `core_logic` always replies two cycles after receiving a command
					when st_wait =>
						axilite_state <= st_waitfor_bready;

					-- Wait for AXI Lite Port to assert `bready`
					when st_waitfor_bready =>
						axilite_state <= st_transmit_resp when axilite_bready = '1' else st_waitfor_bready;

					-- The response will be forwarded to the AXI Lite Port
					when st_transmit_resp =>
						axilite_state <= st_idle;
				end case;
			end if;
		end if;
	end process;


	-- Address Receiver Register
	process(data_clk)
	begin
		if rising_edge(data_clk) then
			if data_rst = '1' then
				axilite_got_addr <= '0';
				reg_addr <= (others=>'0');
			-- Update address register if we are expecting a new command
			elsif axilite_awvalid = '1' and axilite_state = st_idle and axilite_got_addr = '0' then
				reg_addr <= axilite_awaddr;
				axilite_got_addr <= '1';
			-- Reset flag after transmition
			elsif axilite_state = st_waitfor_bready then
				axilite_got_addr <= '0';
			end if;
		end if;
	end process;

	-- Data Receiver Register
	process(data_clk)
	begin
		if rising_edge(data_clk) then
			if data_rst = '1' then
				axilite_got_data <= '0';
				reg_data <= (others=>'0');
			elsif axilite_wvalid = '1' and axilite_state = st_idle and axilite_got_data = '0' then
				reg_data <= axilite_wdata;
				axilite_got_data <= '1';
			elsif axilite_state = st_waitfor_bready then
				axilite_got_data <= '0';
			end if;
		end if;
	end process;

	-- AXI Lite Response Buffer
	process(data_clk)
	begin
		if rising_edge(data_clk) then
			if data_rst = '1' then
				reg_resp <= (others=>'0');
				axilite_got_resp <= '0';
			-- Update `reg_resp` once, during `st_waitfor_bready`
			-- elsif (axilite_state = st_transmit_resp or axilite_state = st_waitfor_bready) and axilite_got_resp = '0' then
			elsif axilite_state = st_waitfor_bready and axilite_got_resp = '0' then
				reg_resp <= corlog_resp_out;
				axilite_got_resp <= '1';
			-- Keep `reg_resp` until a transmition starts again
			elsif axilite_state = st_transmit_resp then
				axilite_got_resp <= '0';
			end if;
		end if;
	end process;

	-- Response Valid Handler
	process(data_clk)
	begin
		if rising_edge(data_clk) then
			if data_rst = '1' then
				axilite_bvalid <= '0';
			else
				if axilite_state = st_waitfor_bready then
					axilite_bvalid <= '1';
				else
					axilite_bvalid <= '0';
				end if;
			end if;
		end if;
	end process;

	-- Instantiation of Core Logic Component
	core_logic_component : core_logic
	generic map (
		g_axi_port_width	=> G_AXI_STREAM_TDATA_WIDTH,
		g_input_elem_width 	=> 8,
		g_output_elem_width	=> 16,
		g_ctrl_address_width=> G_S_AXI_Settings_ADDR_WIDTH,
		g_ctrl_data_width	=> G_S_AXI_Settings_DATA_WIDTH
	)
	port map (
		DATA_CLK => data_clk,
		RST => data_rst,

		CONTROL_START => corlog_ctrl_start,
		CONTROL_READY => corlog_ctrl_ready,
		-- `core_logic` is wired to the AXI Lite Broker's registers and will simply
		-- read them once the broker raises `CONTROL_START`
		CONTROL_ADDR  => reg_addr,
		CONTROL_DATA  => reg_data,
		CONTROL_RESP  => corlog_resp_out,

		DATAIN_VALID  => S_AXI_STREAM_TVALID,
		DATAIN_READY  => S_AXI_STREAM_TREADY,
		DATAIN_LAST   => S_AXI_STREAM_TLAST,
		DATAIN => S_AXI_STREAM_TDATA,

		DATAOUT_VALID => M_AXI_STREAM_TVALID,
		DATAOUT_READY => M_AXI_STREAM_TREADY,
		DATAOUT_LAST  => M_AXI_STREAM_TLAST,
		DATAOUT => M_AXI_STREAM_TDATA
	);

	-- Many signals of the AXI Ports are unused; Hardwire them to constants
	S_AXI_SETTINGS_ARREADY  <= c_low;
	S_AXI_SETTINGS_RDATA	<= (others=>'0');
	S_AXI_SETTINGS_RRESP	<= (others=>'0');
	S_AXI_SETTINGS_RVALID	<= c_low;

	-- Ports of Axi Master Bus Interface M_AXI_STREAM
	M_AXI_STREAM_TSTRB <= (others=>'1');

end arch_imp;
